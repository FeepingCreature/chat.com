module chat;

macro import cx.macros.assert;
macro import cx.macros.cimport;

import c_header("ctype.h");
import c_header("string.h");
import c_header("unistd.h");

import helpers : itoa, print;
import std.string;

import irc;
import terminal;
import time;
import utf;

void main() {
    print("Starting.");

    /*Buffer render_(int rows, int cols) {
        return new Buffer(rows, cols);
    }
    void enter_() { }
    auto term = new Terminal(&render_, &enter_);
    term.enableRawMode;
    keyDebugLoop;
    term.disableRawMode;
    return;*/

    string channel = "##test";
    auto irc = new IRC;

    irc.connect("irc.libera.chat", 6667);
    irc.sendln("NICK test_cx");
    irc.sendln("USER test_cx * * :test_cx");

    while (!irc.ready) {
        irc.pump;
    }
    irc.sendln("JOIN " ~ channel);

    mut Terminal term;

    Buffer refresh(int rows, int cols) {
        irc.pump;

        // print("render(" ~ rows.itoa ~ ", " ~ cols.itoa ~ ")");
        auto buf = new Buffer(rows, cols);
        mut auto view = buf.view;

        view.clear(Color.blue);

        // title line
        view.go(0, 0);
        view.bg(Color.grey).fg(Color.red).print("  H");
        view.fg(Color.black).print("ell World");
        view.fillRow;
        view = view.shrink(top_rows=1, 0, 0, 0);

        // status line
        view.go(-1, 0).bg(Color.grey).fg(Color.black);
        view.print(" Welcome to TUI IRC Demo");
        view.printRight("[ " ~ Time.now.local ~ " ] ");
        view = view.shrink(0, 0, bottom_rows=1, 0);

        // chat box
        view.fg(Color.lwhite).bg(Color.blue).printPrettyBox(0, 0, view.rows - 1, view.cols - 1);

        // input line
        view.go(-1, 2);
        view.bg(Color.blue).fg(Color.lwhite);
        view.print("╡");
        view.bg(Color.blue).printRight("╞══╝");
        view.fg(Color.lyellow);
        view.go(-1, 3).print(" ").print(term.inputLine);

        view = view.shrink(1, 1, 1, 1);

        string[] splitLines(Message msg) {
            int space = view.cols - cast(int) (" [00:00:00] <".length + msg.name.length + "> ".length);
            assert(space > 0);

            mut string[] result;
            mut string remainder = msg.line;
            while (remainder.length > 0) {
                auto prefix = remainder.takeTiles(space);
                result ~= prefix;
                remainder = remainder[prefix.length .. $];
            }
            return result;
        }
        int needsLines(Message msg) {
            // TODO without allocation?
            return cast(int) msg.splitLines.length;
        }

        int availableLines = view.rows;
        mut int usedLines;
        mut int firstMessage = cast(int) irc.messages.length;
        while (firstMessage > 0) {
            firstMessage -= 1;
            usedLines += irc.messages[firstMessage].needsLines;
            if (usedLines >= availableLines)
                break;
        }
        mut int paneRow = availableLines - usedLines;
        for (auto msg <- irc.messages[firstMessage .. $]) {
            string[] msgLines = msg.splitLines;
            for (mut int i = 0; i < msgLines.length; i += 1) {
                // skip occluded lines
                // TODO masking
                view.go(paneRow, 0);
                if (i == 0) {
                    view.bg(Color.blue).fg(Color.black).print(" [" ~ msg.time.local ~ "]");
                    view.skip(1).fg(Color.white).print("<");
                    view.fg(Color.lwhite).print(msg.name);
                    view.fg(Color.white).print(">").skip(1);
                } else {
                    view.skip(cast(int) ("[00:00:00] <".length + msg.name.length + "> ".length));
                }
                paneRow += 1;
                view.fg(Color.lwhite).print(msgLines[i]);
            }
        }
        return buf;
    }
    void enter() {
        string line = term.inputLine;

        if (line == "/q" || line == "/quit") {
            irc.sendln("QUIT");
            term.running = false;
            return;
        }
        if (line.startsWith("/me ")) {
            string action = line[4 .. $];
            irc.messages ~= Message(Time.now, "feep[cx]", "* feep[cx] " ~ action);
            irc.sendln("PRIVMSG " ~ channel ~ " :\x01ACTION " ~ action ~ "\x01");
            return;
        }
        irc.messages ~= Message(Time.now, "feep[cx]", line);
        irc.sendln("PRIVMSG " ~ channel ~ " :" ~ line);
    }

    term = new Terminal(&refresh, &enter);
    term.updateLoop;
}

void printPrettyBox(View view, int r0, int c0, int r1, int c1) {
    view.go(r0, c0).print("╔");
    for (int i <- 0 .. c1 - c0 - 1) {
        view.print("═");
    }
    view.print("╗");
    for (int i <- r0 + 1 .. r1) {
        view.go(i, c0).print("║");
        view.go(i, c1).print("║");
    }
    view.go(r1, c0).print("╚");
    for (int i <- 0 .. c1 - c0 - 1) {
        view.print("═");
    }
    view.print("╝");
}

// Amount of tiles needed to render the text
int tileLength(string text) {
    // TODO full-width characters
    // TODO filter ansi
    return text.utf8Length;
}

// return an n-tile length prefix of text.
string takeTiles(string text, int length) {
    // TODO full-width characters
    // TODO filter ansi
    mut int offset;
    while (offset < text.length && offset + text[offset .. $].utf8NextLength <= length)
    {
        offset += text[offset .. $].utf8NextLength;
    }
    return text[0 .. offset];
}

void keyDebugLoop() {
    mut char c;
    while (c != "q"[0]) {
        c = 0;
        read(STDIN_FILENO, &c, 1);
        if (c == cast(char) 0) continue;
        if (iscntrl(c)) {
            print(itoa(c));
        } else {
            print(itoa(c) ~ " (" ~ c ~ ")");
        }
    }
}

int min(int a, int b) {
    if (a < b) return a;
    return b;
}
