module terminal;

macro import cx.macros.cimport;

import c_header("ctype.h");
import c_header("stdio.h");
import c_header("sys/ioctl.h");
import c_header("termios.h");
import c_header("unistd.h");

import helpers : itoa;

import utf;

class Terminal
{
    termios original;

    Buffer currentScreenState;

    string inputLine;

    Buffer delegate(int, int) render;

    void delegate() enter;

    bool running;

    (int rows, int cols) getSize() {
        mut winsize sz;
        ioctl(0, TIOCGWINSZ, &sz);
        return (sz.ws_row, sz.ws_col);
    }

    this(this.render, this.enter) {
        auto sz = getSize;

        this.currentScreenState = new Buffer(sz.rows, sz.cols);
        this.running = true;
    }

    void update() {
        auto sz = getSize;
        auto newbuf = render(sz.rows, sz.cols);
        paint(newbuf);
    }

    void updateLoop() {
        enableRawMode;
        mut char c;
        while (running) {
            update;
            c = 0;
            read(STDIN_FILENO, &c, 1);
            if (c == cast(char) 0) continue;
            if (c == cast(char) 10) {
                enter();
                inputLine = "";
                continue;
            }
            if ((c == cast(char) 127 || c == cast(char) 8) && inputLine.length > 0) {
                inputLine = inputLine[0 .. $ - 1];
                continue;
            }
            if (!iscntrl(c) && cast(int) c < 127) {
                inputLine ~= c;
            }
        }
        disableRawMode;
    }

    void paint(Buffer newBuf) {
        // TODO compare tuples
        bool refresh = newBuf.rows != currentScreenState.rows || newBuf.cols != currentScreenState.cols;
        mut Color fg, bg;
        for (int i <- 0 .. newBuf.rows) {
            auto line = newBuf.line(i);
            mut bool mustGoTo = true;
            for (int k <- 0 .. newBuf.cols) {
                auto tile = line[k];
                if (!refresh) {
                    auto oldLine = currentScreenState.line(i);
                    auto oldTile = oldLine[k];
                    if (tile.eq(oldTile)) {
                        mustGoTo = true;
                        continue;
                    }
                }
                if (mustGoTo) {
                    puts("\x1B[" ~ itoa(i + 1) ~ ";" ~ itoa(k + 1) ~ "H");
                    mustGoTo = false;
                }
                if (fg != tile.fg || bg != tile.bg) {
                    int translate(Color c) {
                        int i = cast(int) c;
                        if (i > 7) return 90 + i - 8;
                        return 30 + i;
                    }
                    puts("\x1B[" ~ itoa(translate(tile.fg)) ~ ";" ~ itoa(translate(tile.bg) + 10) ~ "m");
                    fg = tile.fg;
                    bg = tile.bg;
                }
                puts(tile.ch);
            }
        }
        puts("\x1B[" ~ itoa(newBuf.row + 1) ~ ";" ~ itoa(newBuf.col + 1) ~ "H");
        // TODO why does this leak otherwise?
        this.currentScreenState.text = [];
        this.currentScreenState = newBuf;
    }

    void enableRawMode() {
        tcgetattr(STDIN_FILENO, &this.original);
        mut auto raw = this.original;
        raw.c_lflag = raw.c_lflag & (ECHO | ICANON).bitflip;
        // raw.c_cc[VMIN] = 0;
        // raw.c_cc[VTIME] = 1;
        raw.c_cc._6 = 0;
        raw.c_cc._5 = 1;
        tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
        puts("\x1B[?1049h");
    }

    void disableRawMode() {
        tcsetattr(STDIN_FILENO, TCSAFLUSH, &original);
        puts("\x1B[?1049l");
    }
}

struct Tile
{
    string ch; // may be unicode, TODO int
    Color fg, bg;

    // TODO default gen
    bool eq(Tile other) {
        return ch == other.ch && fg == other.fg && bg == other.bg;
    }
}

enum Color
{
    black,
    red,
    green,
    yellow,
    blue,
    magenta,
    cyan,
    white,
    grey,
    lred,
    lgreen,
    lyellow,
    lblue,
    lmagenta,
    lcyan,
    lwhite
}

class Buffer
{
    int rows, cols;

    Tile[] text;

    // print state, todo factor out into renderer?
    Color fg_, bg_;

    int row, col;

    this(this.rows, this.cols) {
        this.fg_ = Color.lwhite;
        this.bg_ = Color.black;
        this.text = new Tile[](this.rows * this.cols);
        clear(this.bg_);
    }

    int rowsLeft() {
        return cols - col;
    }

    Buffer print(string msg) {
        // TODO cutoff
        mut int i;
        while (i < msg.length) {
            auto chlen = msg[i .. $].utf8NextLength;
            auto ch = msg[i .. i + chlen];
            this.text[this.row * this.cols + this.col] = Tile(ch, this.fg_, this.bg_);
            i += chlen;
            this.col += 1;
        }
        return this;
    }

    Buffer printRight(string msg) {
        // TODO cutoff
        int start = this.row * this.cols;
        for (int i <- this.col .. this.cols - msg.utf8Length) {
            this.text[start + i] = Tile(" ", this.fg_, this.bg_);
            this.col += 1;
        }
        mut int k;
        for (int i <- 0 .. msg.utf8Length) {
            auto chlen = msg[k .. $].utf8NextLength;
            auto ch = msg[k .. k + chlen];
            k += chlen;
            this.text[start + this.col] = Tile(ch, this.fg_, this.bg_);
            this.col += 1;
        }
        return this;
    }

    Buffer go(mut int row, mut int col) {
        if (row < 0) row = this.rows - -row;
        if (col < 0) col = this.cols - -col;
        this.row = row;
        this.col = col;
        return this;
    }

    Buffer fg(Color fg) {
        this.fg_ = fg;
        return this;
    }

    Buffer bg(Color bg) {
        this.bg_ = bg;
        return this;
    }

    Buffer clear(Color bg) {
        this.bg_ = bg;
        for (int i <- 0 .. this.text.length) {
            this.text[i] = Tile(" ", this.fg_, this.bg_);
        }
        return this;
    }

    Buffer skip(int cols) {
        this.col += cols;
        return this;
    }

    Buffer fillRow() {
        int base = this.row * this.cols + this.col;
        for (int i <- 0 .. this.cols - this.col) {
            this.text[base + i] = Tile(" ", this.fg_, this.bg_);
        }
    }

    Tile[] line(int row) {
        return this.text[this.cols * row .. this.cols * (row + 1)];
    }
}

// TODO variadics
extern(C) int ioctl(int, int, void*);

void puts(string msg) {
    write(STDOUT_FILENO, msg.ptr, msg.length);
}

int bitflip(int i) { return -i - 1; }
